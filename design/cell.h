#pragma once

#include "common.h"
#include "formula.h"

#include <memory>
#include <set>

class Impl;

class Cell;

namespace RawCellImpl{
//данный интерфейс используется для получения доступа к ячейке без необходимости ее приведения к типу Cell*
//из типа CellInterface* с помощью dynamic_cast. Интерфейс вводится для избегания круговой зависимости между файлами
//cell.h и sheet.h. Логично, что Sheet может зависеть от Cell, а не только от CellInerface
class GetRawCellInterface {
    virtual const Cell* GetRawCell(Position) const = 0;
};
};

class Cell : public CellInterface {
public:
    Cell(SheetInterface& sheet);
    ~Cell();

    //Алгоритм работы Set:
    //В обработчике исключений создать новую имплементацию в временном impl_new, для защиты от искоючений
    //impl_new и impl_ меняются местами
    //Проверить циклические зависимости списке, вернуть старую имплементацию и выбросить исключение, если цикл найден (метод HasCircularDependencies)
    //Пройтись по всем элемнетам списка родительских ячеек старой имплементации и убрать текущую ячейку из их контейнера зависящих от них ячеек (метод DeleteDependentCell)
    //Пройтись по родительским ячейкам новой импелемнтации и добавить текущую ячейку в контейнер зависимых от них. В случае, если такой ячейки не существует, создать как пустую
    //Пройтись по списку зависящих ячеек от текущей имплементации (dependent_cells_) и инвалидировать Кэш каждой ячейки
    void Set(std::string text);
    void Clear();

    Value GetValue() const override;
    std::string GetText() const override;\
    
    //возврат ячеек, задействованных в формуле. Список ячеек будет храниться внутри класса FormulaAST
    std::vector<Position> GetReferencedCells() const override;
private:
    //метод, сбрасывающий кэш ячейки. Должен быть константным, так как кэш - лишь тонкость реализации
    //метод должен сбросить кэш как данной ячейки через интерфейс Impl, так и всех зависимых ячеек в контейнере dependent_cells_,
    //вызвав в них такой же методю
    //Введение интерфейса RawCell
    void CacheReset() const; 

    //Этот метод реализует рекурсивный обход графа зависимостей ячеек в глубину. 
    //Благодаря введению интерфейса GetRawCellInterface стало возможным получать указатель Cell*,
    //а значит, вызывать этот метод при рекурсивном обходе.
    //В аргумент передается указатель на ячейку, с которой начинается обход. Обход выполняется
    //рекурсивно начиная с певрого элемента контейнера, возвращаемого методом GetReferencedCells (контейнера родительских ячеек, сохраняемого во временную переменную).
    //Возврат true означает, что циклическая зависмость найдена.
    //Условием остановки рекурсии (раскуртуки стека) является нахождение циклической зависимости
    //(т.е указаетля на начальную ячейку среди родительских) либо пустой контейнер родительских ячеек 
    //(то есть ячейа не ссылается на другие)
    bool HasCircularDependecies(Cell* start_cell) const;

    //Метод, добавляющий зависящую от данной ячейку. Предполагается вызов только объектами того же класса, поэтому запривачен
    void AddDependentCell(Cell* pos);
    
    //Метод, убирающий зависящую от данной ячейку. 
    void DeleteDependentCell(Cell* pos);

    SheetInterface& sheet_;
    std::unique_ptr<Impl> cell_impl_;

    //Множество ячеек, сслающихся на ячейку. Хранится в виде указателей, так как сама ячейка не знает
    //о своей позиции в таблице. Так проще отслеживать зависимости
    std::set<Cell*> dependent_cells_;
};